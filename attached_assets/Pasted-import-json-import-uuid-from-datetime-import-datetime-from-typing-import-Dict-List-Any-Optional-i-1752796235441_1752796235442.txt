import json
import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
import requests
from dataclasses import dataclass, asdict
from flask import Flask, request, jsonify
import networkx as nx
import sqlite3
import os

@dataclass
class Course:
    code: str
    title: str
    credits: int
    track: str
    requirement_type: str  # 'mandatory', 'choice', 'elective'
    group_id: Optional[str] = None
    prerequisites: List[str] = None
    description: Optional[str] = None
    
    def __post_init__(self):
        if self.prerequisites is None:
            self.prerequisites = []

@dataclass
class Track:
    name: str
    code: str
    required_courses: int
    elective_courses: int
    mandatory_courses: List[str]
    choice_groups: Dict[str, Dict]
    elective_options: List[str]
    special_rules: Dict[str, str]
    last_updated: str

@dataclass
class TrainingData:
    id: str
    query: str
    response: str
    track: str
    confidence: float
    source_data: Dict
    created_at: str

class KnowledgeGraph:
    def __init__(self, db_path: str = "purdue_cs_knowledge.db"):
        self.db_path = db_path
        self.graph = nx.DiGraph()
        self.init_database()
        
    def init_database(self):
        """Initialize SQLite database for persistent storage"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Courses table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS courses (
                code TEXT PRIMARY KEY,
                title TEXT NOT NULL,
                credits INTEGER,
                track TEXT,
                requirement_type TEXT,
                group_id TEXT,
                prerequisites TEXT,
                description TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Tracks table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS tracks (
                code TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                required_courses INTEGER,
                elective_courses INTEGER,
                mandatory_courses TEXT,
                choice_groups TEXT,
                elective_options TEXT,
                special_rules TEXT,
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Training data table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS training_data (
                id TEXT PRIMARY KEY,
                query TEXT NOT NULL,
                response TEXT NOT NULL,
                track TEXT,
                confidence REAL,
                source_data TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Knowledge graph edges
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS knowledge_edges (
                id TEXT PRIMARY KEY,
                source_node TEXT,
                target_node TEXT,
                relationship TEXT,
                properties TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def add_course(self, course: Course) -> bool:
        """Add course to knowledge graph and database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO courses 
                (code, title, credits, track, requirement_type, group_id, prerequisites, description)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                course.code, course.title, course.credits, course.track,
                course.requirement_type, course.group_id, 
                json.dumps(course.prerequisites), course.description
            ))
            
            # Add to graph
            self.graph.add_node(course.code, **asdict(course))
            
            # Add prerequisite edges
            for prereq in course.prerequisites:
                self.graph.add_edge(prereq, course.code, relationship="prerequisite")
                self._add_knowledge_edge(prereq, course.code, "prerequisite", {})
            
            conn.commit()
            conn.close()
            return True
            
        except Exception as e:
            print(f"Error adding course {course.code}: {e}")
            return False
    
    def add_track(self, track: Track) -> bool:
        """Add track to knowledge graph and database"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO tracks 
                (code, name, required_courses, elective_courses, mandatory_courses, 
                 choice_groups, elective_options, special_rules)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                track.code, track.name, track.required_courses, track.elective_courses,
                json.dumps(track.mandatory_courses), json.dumps(track.choice_groups),
                json.dumps(track.elective_options), json.dumps(track.special_rules)
            ))
            
            # Add to graph
            self.graph.add_node(f"track_{track.code}", **asdict(track))
            
            # Connect track to courses
            for course_code in track.mandatory_courses:
                self.graph.add_edge(f"track_{track.code}", course_code, relationship="requires")
                self._add_knowledge_edge(f"track_{track.code}", course_code, "requires", {"type": "mandatory"})
            
            for course_code in track.elective_options:
                self.graph.add_edge(f"track_{track.code}", course_code, relationship="allows")
                self._add_knowledge_edge(f"track_{track.code}", course_code, "allows", {"type": "elective"})
            
            conn.commit()
            conn.close()
            return True
            
        except Exception as e:
            print(f"Error adding track {track.code}: {e}")
            return False
    
    def _add_knowledge_edge(self, source: str, target: str, relationship: str, properties: Dict):
        """Add edge to knowledge graph database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        edge_id = str(uuid.uuid4())
        cursor.execute('''
            INSERT INTO knowledge_edges (id, source_node, target_node, relationship, properties)
            VALUES (?, ?, ?, ?, ?)
        ''', (edge_id, source, target, relationship, json.dumps(properties)))
        
        conn.commit()
        conn.close()
    
    def query_courses_by_track(self, track_code: str) -> Dict[str, List[Course]]:
        """Query all courses for a specific track"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT code, title, credits, track, requirement_type, group_id, prerequisites, description
            FROM courses WHERE track = ?
        ''', (track_code,))
        
        rows = cursor.fetchall()
        conn.close()
        
        courses = {
            "mandatory": [],
            "choice": [],
            "elective": []
        }
        
        for row in rows:
            prereqs = json.loads(row[6]) if row[6] else []
            course = Course(
                code=row[0], title=row[1], credits=row[2], track=row[3],
                requirement_type=row[4], group_id=row[5], 
                prerequisites=prereqs, description=row[7]
            )
            courses[course.requirement_type].append(course)
        
        return courses
    
    def get_track_info(self, track_code: str) -> Optional[Track]:
        """Get complete track information"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT code, name, required_courses, elective_courses, mandatory_courses,
                   choice_groups, elective_options, special_rules, last_updated
            FROM tracks WHERE code = ?
        ''', (track_code,))
        
        row = cursor.fetchone()
        conn.close()
        
        if not row:
            return None
        
        return Track(
            code=row[0], name=row[1], required_courses=row[2], elective_courses=row[3],
            mandatory_courses=json.loads(row[4]), choice_groups=json.loads(row[5]),
            elective_options=json.loads(row[6]), special_rules=json.loads(row[7]),
            last_updated=row[8]
        )
    
    def find_course_relationships(self, course_code: str) -> Dict[str, List[str]]:
        """Find all relationships for a course"""
        relationships = {
            "prerequisites": [],
            "dependent_courses": [],
            "tracks_requiring": [],
            "tracks_allowing": []
        }
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Find prerequisites
        cursor.execute('''
            SELECT source_node FROM knowledge_edges 
            WHERE target_node = ? AND relationship = "prerequisite"
        ''', (course_code,))
        relationships["prerequisites"] = [row[0] for row in cursor.fetchall()]
        
        # Find dependent courses
        cursor.execute('''
            SELECT target_node FROM knowledge_edges 
            WHERE source_node = ? AND relationship = "prerequisite"
        ''', (course_code,))
        relationships["dependent_courses"] = [row[0] for row in cursor.fetchall()]
        
        # Find tracks requiring this course
        cursor.execute('''
            SELECT source_node FROM knowledge_edges 
            WHERE target_node = ? AND relationship = "requires"
        ''', (course_code,))
        relationships["tracks_requiring"] = [row[0] for row in cursor.fetchall()]
        
        # Find tracks allowing this course as elective
        cursor.execute('''
            SELECT source_node FROM knowledge_edges 
            WHERE target_node = ? AND relationship = "allows"
        ''', (course_code,))
        relationships["tracks_allowing"] = [row[0] for row in cursor.fetchall()]
        
        conn.close()
        return relationships

class PurdueDataLoader:
    def __init__(self, knowledge_graph: KnowledgeGraph):
        self.kg = knowledge_graph
        
    def load_machine_intelligence_track(self):
        """Load MI track data from scrapers into knowledge graph"""
        from mi_track_scraper import PurdueMITrackScraper
        
        scraper = PurdueMITrackScraper()
        data = scraper.scrape_courses()
        
        if not data:
            return False
        
        # Create MI track
        mi_track = Track(
            name="Machine Intelligence Track",
            code="MI",
            required_courses=4,
            elective_courses=2,
            mandatory_courses=["CS 37300", "CS 38100"],
            choice_groups={
                "ai_requirement": {
                    "options": ["CS 47100", "CS 47300"],
                    "choose": 1,
                    "description": "AI Requirement"
                },
                "stats_requirement": {
                    "options": ["STAT 41600", "MA 41600", "STAT 51200"],
                    "choose": 1,
                    "description": "Statistics/Probability Requirement"
                }
            },
            elective_options=[
                "CS 31100", "CS 41100", "CS 31400", "CS 34800", "CS 35200",
                "CS 44800", "CS 45600", "CS 45800", "CS 47100", "CS 47300",
                "CS 48300", "CS 43900", "CS 44000", "CS 47500", "CS 57700", "CS 57800"
            ],
            special_rules={
                "competitive_programming": "CS 31100 + CS 41100 together may count as 1 elective",
                "data_group": "From CS 43900/CS 44000/CS 47500, can only pick ONE",
                "no_double_counting": "Cannot use same course for required AND elective"
            },
            last_updated=datetime.now().isoformat()
        )
        
        self.kg.add_track(mi_track)
        
        # Add courses
        courses_to_add = [
            Course("CS 37300", "Data Mining and Machine Learning", 3, "MI", "mandatory"),
            Course("CS 38100", "Introduction to the Analysis of Algorithms", 3, "MI", "mandatory"),
            Course("CS 47100", "Artificial Intelligence", 3, "MI", "choice", "ai_requirement"),
            Course("CS 47300", "Web Information Search & Management", 3, "MI", "choice", "ai_requirement"),
            Course("STAT 41600", "Probability", 3, "MI", "choice", "stats_requirement"),
            Course("MA 41600", "Probability", 3, "MI", "choice", "stats_requirement"),
            Course("STAT 51200", "Applied Regression Analysis", 3, "MI", "choice", "stats_requirement"),
        ]
        
        # Add electives
        elective_courses = [
            ("CS 31100", "Competitive Programming 2 and 3"),
            ("CS 41100", "Competitive Programming continuation"),
            ("CS 31400", "Numerical Methods"),
            ("CS 34800", "Information Systems"),
            ("CS 35200", "Compilers: Principles And Practice"),
            ("CS 44800", "Introduction To Relational Database Systems"),
            ("CS 45600", "Programming Languages"),
            ("CS 45800", "Introduction to Robotics"),
            ("CS 48300", "Introduction To The Theory Of Computation"),
            ("CS 43900", "Introduction to Data Visualization"),
            ("CS 44000", "Large-Scale Data Analytics"),
            ("CS 47500", "Human-Computer Interactions"),
            ("CS 57700", "Natural Language Processing"),
            ("CS 57800", "Statistical Machine Learning")
        ]
        
        for code, title in elective_courses:
            courses_to_add.append(Course(code, title, 3, "MI", "elective"))
        
        for course in courses_to_add:
            self.kg.add_course(course)
        
        return True
    
    def load_software_engineering_track(self):
        """Load SE track data from scrapers into knowledge graph"""
        from se_track_scraper import PurdueSETrackScraper
        
        scraper = PurdueSETrackScraper()
        data = scraper.scrape_courses()
        
        if not data:
            return False
        
        # Create SE track
        se_track = Track(
            name="Software Engineering Track",
            code="SE",
            required_courses=5,
            elective_courses=1,
            mandatory_courses=["CS 30700", "CS 38100", "CS 40800", "CS 40700"],
            choice_groups={
                "compilers_os_requirement": {
                    "options": ["CS 35200", "CS 35400"],
                    "choose": 1,
                    "description": "Compilers or Operating Systems"
                }
            },
            elective_options=[
                "CS 31100", "CS 41100", "CS 34800", "CS 35100", "CS 35200",
                "CS 35300", "CS 35400", "CS 37300", "CS 42200", "CS 42600",
                "CS 44800", "CS 45600", "CS 47100", "CS 47300", "CS 48900",
                "CS 49000-DSO", "CS 49000-SWS", "CS 51000", "CS 59000-SRS"
            ],
            special_rules={
                "competitive_programming": "CS 31100 + CS 41100 together satisfy one elective",
                "senior_project_substitute": "EPICS/VIP can replace CS 40700 with track chair approval",
                "epics_requirement": "EPICS must be EPCS 41100+41200 (Senior Design)",
                "no_double_counting": "Cannot use same course for required AND elective"
            },
            last_updated=datetime.now().isoformat()
        )
        
        self.kg.add_track(se_track)
        
        # Add SE courses
        se_courses = [
            Course("CS 30700", "Software Engineering I", 3, "SE", "mandatory"),
            Course("CS 38100", "Introduction to the Analysis of Algorithms", 3, "SE", "mandatory"),
            Course("CS 40800", "Software Testing", 3, "SE", "mandatory"),
            Course("CS 40700", "Software Engineering Senior Project", 3, "SE", "mandatory"),
            Course("CS 35200", "Compilers: Principles and Practice", 3, "SE", "choice", "compilers_os_requirement"),
            Course("CS 35400", "Operating Systems", 3, "SE", "choice", "compilers_os_requirement"),
        ]
        
        # Add SE electives
        se_elective_courses = [
            ("CS 31100", "Competitive Programming 2 and 3"),
            ("CS 41100", "Competitive Programming continuation"),
            ("CS 34800", "Information Systems"),
            ("CS 35100", "Cloud Computing"),
            ("CS 35300", "Principles of Concurrency and Parallelism"),
            ("CS 37300", "Data Mining and Machine Learning"),
            ("CS 42200", "Computer Networks"),
            ("CS 42600", "Computer Security"),
            ("CS 44800", "Introduction to Relational Database Systems"),
            ("CS 45600", "Programming Languages"),
            ("CS 47100", "Introduction to Artificial Intelligence"),
            ("CS 47300", "Web Information Search And Management"),
            ("CS 48900", "Embedded Systems"),
            ("CS 49000-DSO", "Distributed Systems"),
            ("CS 49000-SWS", "Software Security"),
            ("CS 51000", "Software Engineering"),
            ("CS 59000-SRS", "Software Reliability and Security")
        ]
        
        for code, title in se_elective_courses:
            se_courses.append(Course(code, title, 3, "SE", "elective"))
        
        for course in se_courses:
            self.kg.add_course(course)
        
        return True

class DynamicResponseGenerator:
    def __init__(self, knowledge_graph: KnowledgeGraph):
        self.kg = knowledge_graph
        
    def generate_response(self, query: str, track_context: Optional[str] = None) -> Dict[str, Any]:
        """Generate dynamic response based on knowledge graph data"""
        query_lower = query.lower()
        response_data = {
            "query": query,
            "response": "",
            "confidence": 0.0,
            "source_data": {},
            "track": track_context
        }
        
        # Detect query type and track
        if not track_context:
            if "mi" in query_lower or "machine intelligence" in query_lower:
                track_context = "MI"
            elif "se" in query_lower or "software engineering" in query_lower:
                track_context = "SE"
        
        # Route to appropriate handler
        if "required" in query_lower and "courses" in query_lower:
            return self._handle_required_courses_query(query, track_context)
        elif "elective" in query_lower:
            return self._handle_electives_query(query, track_context)
        elif "difference" in query_lower or "compare" in query_lower:
            return self._handle_comparison_query(query)
        elif any(course_pattern in query_lower for course_pattern in ["cs ", "stat ", "ma "]):
            return self._handle_course_specific_query(query, track_context)
        else:
            return self._handle_general_query(query, track_context)
    
    def _handle_required_courses_query(self, query: str, track_context: str) -> Dict[str, Any]:
        """Handle queries about required courses"""
        if not track_context:
            return {
                "query": query,
                "response": "Please specify which track you're asking about: Machine Intelligence (MI) or Software Engineering (SE).",
                "confidence": 0.5,
                "source_data": {},
                "track": None
            }
        
        track = self.kg.get_track_info(track_context)
        if not track:
            return {
                "query": query,
                "response": f"Track {track_context} not found in knowledge base.",
                "confidence": 0.0,
                "source_data": {},
                "track": track_context
            }
        
        courses = self.kg.query_courses_by_track(track_context)
        
        response = f"The {track.name} has {track.required_courses} required courses:\n\n"
        
        # Add mandatory courses
        for course in courses["mandatory"]:
            response += f"‚Ä¢ {course.code}: {course.title} (MANDATORY)\n"
        
        # Add choice groups
        for group_name, group_info in track.choice_groups.items():
            response += f"‚Ä¢ {group_info['description']}: Choose {group_info['choose']} from:\n"
            for option in group_info['options']:
                choice_course = next((c for c in courses["choice"] if c.code == option), None)
                if choice_course:
                    response += f"  - {choice_course.code}: {choice_course.title}\n"
                else:
                    response += f"  - {option}\n"
        
        return {
            "query": query,
            "response": response.strip(),
            "confidence": 0.95,
            "source_data": {
                "track": asdict(track),
                "courses": {k: [asdict(c) for c in v] for k, v in courses.items()}
            },
            "track": track_context
        }
    
    def _handle_electives_query(self, query: str, track_context: str) -> Dict[str, Any]:
        """Handle queries about electives"""
        if not track_context:
            return {
                "query": query,
                "response": "Please specify which track you're asking about: Machine Intelligence (MI) or Software Engineering (SE).",
                "confidence": 0.5,
                "source_data": {},
                "track": None
            }
        
        track = self.kg.get_track_info(track_context)
        if not track:
            return {
                "query": query,
                "response": f"Track {track_context} not found in knowledge base.",
                "confidence": 0.0,
                "source_data": {},
                "track": track_context
            }
        
        courses = self.kg.query_courses_by_track(track_context)
        
        response = f"The {track.name} requires {track.elective_courses} elective course{'s' if track.elective_courses > 1 else ''} from the approved list:\n\n"
        
        for course in courses["elective"]:
            response += f"‚Ä¢ {course.code}: {course.title}\n"
        
        # Add special rules
        if track.special_rules:
            response += "\nSpecial Rules:\n"
            for rule_name, rule_desc in track.special_rules.items():
                response += f"‚Ä¢ {rule_desc}\n"
        
        return {
            "query": query,
            "response": response.strip(),
            "confidence": 0.95,
            "source_data": {
                "track": asdict(track),
                "elective_courses": [asdict(c) for c in courses["elective"]]
            },
            "track": track_context
        }
    
    def _handle_comparison_query(self, query: str) -> Dict[str, Any]:
        """Handle queries comparing tracks"""
        mi_track = self.kg.get_track_info("MI")
        se_track = self.kg.get_track_info("SE")
        
        if not mi_track or not se_track:
            return {
                "query": query,
                "response": "Track comparison data not available.",
                "confidence": 0.0,
                "source_data": {},
                "track": "comparison"
            }
        
        response = f"Track Comparison:\n\n"
        response += f"**{mi_track.name}:**\n"
        response += f"‚Ä¢ Structure: {mi_track.required_courses} required + {mi_track.elective_courses} electives\n"
        response += f"‚Ä¢ Focus: AI, Machine Learning, Data Mining, Statistics\n"
        response += f"‚Ä¢ Mandatory courses: {', '.join(mi_track.mandatory_courses)}\n\n"
        
        response += f"**{se_track.name}:**\n"
        response += f"‚Ä¢ Structure: {se_track.required_courses} required + {se_track.elective_courses} elective\n"
        response += f"‚Ä¢ Focus: Software Development, Testing, Project Management\n"
        response += f"‚Ä¢ Mandatory courses: {', '.join(se_track.mandatory_courses)}\n"
        
        return {
            "query": query,
            "response": response.strip(),
            "confidence": 0.95,
            "source_data": {
                "mi_track": asdict(mi_track),
                "se_track": asdict(se_track)
            },
            "track": "comparison"
        }
    
    def _handle_course_specific_query(self, query: str, track_context: str) -> Dict[str, Any]:
        """Handle queries about specific courses"""
        import re
        
        # Extract course code from query
        course_match = re.search(r'(CS|STAT|MA)\s*(\d+)', query.upper())
        if not course_match:
            return {
                "query": query,
                "response": "Could not identify specific course in your query.",
                "confidence": 0.1,
                "source_data": {},
                "track": track_context
            }
        
        course_code = f"{course_match.group(1)} {course_match.group(2)}"
        
        # Find course in knowledge graph
        relationships = self.kg.find_course_relationships(course_code)
        
        # Get course details from database
        conn = sqlite3.connect(self.kg.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            SELECT code, title, credits, track, requirement_type, group_id, description
            FROM courses WHERE code = ?
        ''', (course_code,))
        
        course_data = cursor.fetchone()
        conn.close()
        
        if not course_data:
            return {
                "query": query,
                "response": f"Course {course_code} not found in knowledge base.",
                "confidence": 0.0,
                "source_data": {},
                "track": track_context
            }
        
        response = f"{course_code}: {course_data[1]}\n"
        response += f"Credits: {course_data[2]}\n"
        response += f"Track: {course_data[3]}\n"
        response += f"Type: {course_data[4].title()}\n"
        
        if course_data[5]:  # group_id
            response += f"Group: {course_data[5]}\n"
        
        if relationships["tracks_requiring"]:
            tracks = [t.replace("track_", "") for t in relationships["tracks_requiring"]]
            response += f"Required by tracks: {', '.join(tracks)}\n"
        
        if relationships["tracks_allowing"]:
            tracks = [t.replace("track_", "") for t in relationships["tracks_allowing"]]
            response += f"Available as elective in: {', '.join(tracks)}\n"
        
        return {
            "query": query,
            "response": response.strip(),
            "confidence": 0.90,
            "source_data": {
                "course": {
                    "code": course_data[0],
                    "title": course_data[1],
                    "credits": course_data[2],
                    "track": course_data[3],
                    "requirement_type": course_data[4]
                },
                "relationships": relationships
            },
            "track": track_context
        }
    
    def _handle_general_query(self, query: str, track_context: str) -> Dict[str, Any]:
        """Handle general queries"""
        if track_context:
            track = self.kg.get_track_info(track_context)
            if track:
                response = f"General information about {track.name}:\n"
                response += f"‚Ä¢ Total courses: {track.required_courses + track.elective_courses}\n"
                response += f"‚Ä¢ Required courses: {track.required_courses}\n"
                response += f"‚Ä¢ Elective courses: {track.elective_courses}\n"
                response += f"‚Ä¢ Last updated: {track.last_updated}\n"
                
                return {
                    "query": query,
                    "response": response.strip(),
                    "confidence": 0.7,
                    "source_data": {"track": asdict(track)},
                    "track": track_context
                }
        
        return {
            "query": query,
            "response": "I can help you with information about Purdue CS tracks. Try asking about required courses, electives, or specific course codes.",
            "confidence": 0.3,
            "source_data": {},
            "track": track_context
        }

class N8NIntegration:
    def __init__(self, knowledge_graph: KnowledgeGraph, response_generator: DynamicResponseGenerator):
        self.kg = knowledge_graph
        self.rg = response_generator
        self.app = Flask(__name__)
        self.setup_routes()
        
    def setup_routes(self):
        """Setup Flask routes for n8n integration"""
        
        @self.app.route('/health', methods=['GET'])
        def health_check():
            return jsonify({"status": "healthy", "timestamp": datetime.now().isoformat()})
        
        @self.app.route('/api/query', methods=['POST'])
        def process_query():
            data = request.get_json()
            if not data or 'query' not in data:
                return jsonify({"error": "Missing query parameter"}), 400
            
            query = data['query']
            track_context = data.get('track_context')
            
            response = self.rg.generate_response(query, track_context)
            
            # Store training data
            training_data = TrainingData(
                id=str(uuid.uuid4()),
                query=query,
                response=response['response'],
                track=response['track'] or '',
                confidence=response['confidence'],
                source_data=response['source_data'],
                created_at=datetime.now().isoformat()
            )
            
            self._store_training_data(training_data)
            
            return jsonify(response)
        
        @self.app.route('/api/load-data', methods=['POST'])
        def load_data():
            """Endpoint for n8n to trigger data loading"""
            try:
                loader = PurdueDataLoader(self.kg)
                
                mi_loaded = loader.load_machine_intelligence_track()
                se_loaded = loader.load_software_engineering_track()
                
                return jsonify({
                    "status": "success",
                    "mi_loaded": mi_loaded,
                    "se_loaded": se_loaded,
                    "timestamp": datetime.now().isoformat()
                })
            except Exception as e:
                return jsonify({"status": "error", "message": str(e)}), 500
        
        @self.app.route('/api/training-data', methods=['GET'])
        def get_training_data():
            """Get training data for AI model"""
            conn = sqlite3.connect(self.kg.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT id, query, response, track, confidence, source_data, created_at
                FROM training_data
                ORDER BY created_at DESC
                LIMIT 1000
            ''')
            
            rows = cursor.fetchall()
            conn.close()
            
            training_data = []
            for row in rows:
                training_data.append({
                    "id": row[0],
                    "query": row[1],
                    "response": row[2],
                    "track": row[3],
                    "confidence": row[4],
                    "source_data": json.loads(row[5]) if row[5] else {},
                    "created_at": row[6]
                })
            
            return jsonify({
                "training_data": training_data,
                "count": len(training_data)
            })
        
        @self.app.route('/api/validate-course-plan', methods=['POST'])
        def validate_course_plan():
            """Validate a student's course plan"""
            data = request.get_json()
            if not data or 'courses' not in data or 'track' not in data:
                return jsonify({"error": "Missing courses or track parameter"}), 400
            
            track_code = data['track'].upper()
            courses = data['courses']
            
            if track_code == "MI":
                from course_validator import MITrackValidator
                validator = MITrackValidator()
            elif track_code == "SE":
                from se_course_validator import SETrackValidator
                validator = SETrackValidator()
            else:
                return jsonify({"error": "Invalid track"}), 400
            
            result = validator.validate_course_plan(courses)
            return jsonify(result)
        
        @self.app.route('/api/knowledge-graph/stats', methods=['GET'])
        def knowledge_graph_stats():
            """Get knowledge graph statistics"""
            conn = sqlite3.connect(self.kg.db_path)
            cursor = conn.cursor()
            
            # Count courses by track
            cursor.execute('SELECT track, COUNT(*) FROM courses GROUP BY track')
            course_counts = dict(cursor.fetchall())
            
            # Count training data
            cursor.execute('SELECT COUNT(*) FROM training_data')
            training_count = cursor.fetchone()[0]
            
            # Count knowledge edges
            cursor.execute('SELECT COUNT(*) FROM knowledge_edges')
            edge_count = cursor.fetchone()[0]
            
            conn.close()
            
            return jsonify({
                "courses_by_track": course_counts,
                "training_data_count": training_count,
                "knowledge_edges": edge_count,
                "graph_nodes": self.kg.graph.number_of_nodes(),
                "graph_edges": self.kg.graph.number_of_edges()
            })
    
    def _store_training_data(self, training_data: TrainingData):
        """Store training data in database"""
        conn = sqlite3.connect(self.kg.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO training_data (id, query, response, track, confidence, source_data, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            training_data.id, training_data.query, training_data.response,
            training_data.track, training_data.confidence,
            json.dumps(training_data.source_data), training_data.created_at
        ))
        
        conn.commit()
        conn.close()
    
    def run(self, host='0.0.0.0', port=5000, debug=False):
        """Run the Flask application"""
        self.app.run(host=host, port=port, debug=debug)

def initialize_system():
    """Initialize the complete system"""
    print("üöÄ Initializing Purdue CS Knowledge Graph System...")
    
    # Initialize components
    kg = KnowledgeGraph()
    loader = PurdueDataLoader(kg)
    rg = DynamicResponseGenerator(kg)
    n8n = N8NIntegration(kg, rg)
    
    print("üìö Loading track data...")
    mi_loaded = loader.load_machine_intelligence_track()
    se_loaded = loader.load_software_engineering_track()
    
    print(f"‚úÖ MI Track loaded: {mi_loaded}")
    print(f"‚úÖ SE Track loaded: {se_loaded}")
    
    return kg, rg, n8n

if __name__ == "__main__":
    kg, rg, n8n = initialize_system()
    
    print("üåê Starting n8n integration server...")
    print("Available endpoints:")
    print("  GET  /health - Health check")
    print("  POST /api/query - Process user queries")
    print("  POST /api/load-data - Reload track data")
    print("  GET  /api/training-data - Get training data")
    print("  POST /api/validate-course-plan - Validate course plans")
    print("  GET  /api/knowledge-graph/stats - Knowledge graph statistics")
    
    n8n.run(debug=True)