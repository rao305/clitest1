"""
AI Thinking/Reasoning Layer for Purdue CS Advisor
Implements step-by-step reasoning before generating responses
"""

import json
import sqlite3
from datetime import datetime
from typing import Dict, List, Any, Optional
import requests

class ThinkingAIAdvisor:
    def __init__(self, knowledge_graph, config):
        self.kg = knowledge_graph
        self.config = config
        
    def process_query_with_thinking(self, query: str, track_context: str = None) -> Dict[str, Any]:
        """
        Main method that implements the thinking process
        """
        
        # Step 1: Initial Analysis
        thinking_process = self._start_thinking_process(query, track_context)
        
        # Step 2: Deep Reasoning
        reasoning_result = self._perform_deep_reasoning(thinking_process)
        
        # Step 3: Generate Thoughtful Response
        final_response = self._generate_thoughtful_response(reasoning_result)
        
        return final_response
    
    def _start_thinking_process(self, query: str, track_context: str) -> Dict[str, Any]:
        """
        Step 1: AI analyzes the query and plans its thinking approach
        """
        
        thinking_prompt = f"""You are a Purdue CS advisor AI. Before answering the student's question, you need to think through it step by step.

Student Question: "{query}"
Track Context: {track_context or "Not specified"}

First, analyze this question by thinking through:

1. QUESTION ANALYSIS:
   - What is the student really asking?
   - What type of information do they need?
   - Are there any hidden concerns or implications?
   - What level of detail is appropriate?

2. KNOWLEDGE REQUIREMENTS:
   - What specific course information do I need?
   - What prerequisites or timing rules apply?
   - Are there any special track-specific considerations?
   - What related information might be helpful?

3. REASONING APPROACH:
   - How should I structure my thinking?
   - What potential complications or edge cases exist?
   - How can I provide the most helpful guidance?

Think through each of these areas systematically, then provide your analysis in this JSON format:

{{
  "question_analysis": {{
    "primary_intent": "what they're really asking",
    "information_type": "timing/requirements/planning/advice",
    "student_concerns": ["list of implied concerns"],
    "detail_level": "basic/intermediate/detailed"
  }},
  "knowledge_needed": {{
    "courses": ["list of relevant courses"],
    "concepts": ["prerequisites", "timing", "tracks", etc.],
    "special_rules": ["any special considerations"],
    "related_info": ["additional helpful context"]
  }},
  "reasoning_plan": {{
    "approach": "how to structure the thinking",
    "key_points": ["main points to address"],
    "potential_issues": ["complications to consider"],
    "helpful_additions": ["extra guidance to include"]
  }}
}}

Think carefully and provide detailed analysis."""

        try:
            response = requests.post(
                "https://api.anthropic.com/v1/messages",
                headers={
                    "Content-Type": "application/json",
                    "x-api-key": self.config['anthropic_api_key'],
                    "anthropic-version": "2023-06-01"
                },
                json={
                    "model": "claude-sonnet-4-20250514",
                    "max_tokens": 1500,
                    "messages": [{"role": "user", "content": thinking_prompt}]
                },
                timeout=30
            )
            
            if response.status_code == 200:
                claude_data = response.json()
                thinking_text = claude_data['content'][0]['text']
                
                # Extract JSON from the response
                try:
                    # Find JSON in the response
                    start_idx = thinking_text.find('{')
                    end_idx = thinking_text.rfind('}') + 1
                    json_str = thinking_text[start_idx:end_idx]
                    analysis = json.loads(json_str)
                    
                    return {
                        "original_query": query,
                        "track_context": track_context,
                        "thinking_analysis": analysis,
                        "raw_thinking": thinking_text,
                        "timestamp": datetime.now().isoformat()
                    }
                except json.JSONDecodeError:
                    # Fallback if JSON parsing fails
                    return self._fallback_analysis(query, track_context, thinking_text)
                    
            else:
                return self._fallback_analysis(query, track_context, "API error")
                
        except Exception as e:
            print(f"Error in thinking process: {e}")
            return self._fallback_analysis(query, track_context, str(e))
    
    def _perform_deep_reasoning(self, thinking_process: Dict) -> Dict[str, Any]:
        """
        Step 2: Gather data and perform deep reasoning based on the analysis
        """
        
        analysis = thinking_process.get('thinking_analysis', {})
        courses_needed = analysis.get('knowledge_needed', {}).get('courses', [])
        
        # Gather relevant data from knowledge graph
        relevant_data = self._gather_knowledge_data(courses_needed, thinking_process['track_context'])
        
        # Perform reasoning with Claude
        reasoning_prompt = f"""Now that you've analyzed the question, use the knowledge graph data to reason through the answer.

ORIGINAL QUESTION: {thinking_process['original_query']}

YOUR PREVIOUS ANALYSIS:
{json.dumps(analysis, indent=2)}

RELEVANT KNOWLEDGE GRAPH DATA:
{json.dumps(relevant_data, indent=2)}

Now think through the answer step by step:

1. DATA INTERPRETATION:
   - What does this data tell me about the student's question?
   - Are there any important patterns or relationships?
   - What are the key facts I need to communicate?

2. REASONING PROCESS:
   - How do prerequisites affect the answer?
   - What timing considerations are critical?
   - Are there any potential student misunderstandings to address?
   - What context or background would be helpful?

3. ANSWER STRATEGY:
   - How should I structure my response to be most helpful?
   - What tone and level of detail is appropriate?
   - What additional guidance should I provide?
   - How can I be encouraging while being accurate?

Provide your reasoning in this JSON format:

{{
  "data_interpretation": {{
    "key_facts": ["most important facts"],
    "relationships": ["how things connect"],
    "implications": ["what this means for the student"]
  }},
  "reasoning_steps": [
    "step 1 of reasoning",
    "step 2 of reasoning",
    "step 3 of reasoning"
  ],
  "answer_strategy": {{
    "structure": "how to organize the response",
    "tone": "encouraging/supportive/explanatory",
    "key_messages": ["main points to convey"],
    "additional_guidance": ["extra helpful info"]
  }},
  "potential_followups": ["questions student might ask next"]
}}

Think carefully through each step."""

        try:
            response = requests.post(
                "https://api.anthropic.com/v1/messages",
                headers={
                    "Content-Type": "application/json",
                    "x-api-key": self.config['anthropic_api_key'],
                    "anthropic-version": "2023-06-01"
                },
                json={
                    "model": "claude-sonnet-4-20250514",
                    "max_tokens": 2000,
                    "messages": [{"role": "user", "content": reasoning_prompt}]
                },
                timeout=30
            )
            
            if response.status_code == 200:
                claude_data = response.json()
                reasoning_text = claude_data['content'][0]['text']
                
                try:
                    start_idx = reasoning_text.find('{')
                    end_idx = reasoning_text.rfind('}') + 1
                    json_str = reasoning_text[start_idx:end_idx]
                    reasoning = json.loads(json_str)
                    
                    return {
                        **thinking_process,
                        "reasoning_result": reasoning,
                        "raw_reasoning": reasoning_text,
                        "knowledge_data": relevant_data
                    }
                except json.JSONDecodeError:
                    return {**thinking_process, "reasoning_error": "Could not parse reasoning JSON"}
                    
            else:
                return {**thinking_process, "reasoning_error": f"API error: {response.status_code}"}
                
        except Exception as e:
            return {**thinking_process, "reasoning_error": str(e)}
    
    def _generate_thoughtful_response(self, reasoning_result: Dict) -> Dict[str, Any]:
        """
        Step 3: Generate the final response based on all the thinking and reasoning
        """
        
        # Extract key information
        original_query = reasoning_result['original_query']
        analysis = reasoning_result.get('thinking_analysis', {})
        reasoning = reasoning_result.get('reasoning_result', {})
        
        # Create the final response generation prompt
        final_prompt = f"""Based on your thorough analysis and reasoning, now provide the final response to the student.

STUDENT'S QUESTION: {original_query}

YOUR ANALYSIS AND REASONING:
- Question Intent: {analysis.get('question_analysis', {}).get('primary_intent', 'Unknown')}
- Key Facts: {reasoning.get('data_interpretation', {}).get('key_facts', [])}
- Reasoning Steps: {reasoning.get('reasoning_steps', [])}
- Answer Strategy: {reasoning.get('answer_strategy', {})}

GUIDELINES FOR FINAL RESPONSE:
- Be friendly, encouraging, and conversational
- Use natural language (no markdown formatting)
- Start with an encouraging phrase
- Explain WHY, not just WHAT
- Provide context and reasoning
- End supportively
- Be accurate to the knowledge graph data

Generate a response that shows you've thought through their question carefully and provides genuinely helpful guidance."""

        try:
            response = requests.post(
                "https://api.anthropic.com/v1/messages",
                headers={
                    "Content-Type": "application/json",
                    "x-api-key": self.config['anthropic_api_key'],
                    "anthropic-version": "2023-06-01"
                },
                json={
                    "model": "claude-sonnet-4-20250514",
                    "max_tokens": 1000,
                    "messages": [{"role": "user", "content": final_prompt}]
                },
                timeout=30
            )
            
            if response.status_code == 200:
                claude_data = response.json()
                final_response = claude_data['content'][0]['text']
                
                return {
                    "query": original_query,
                    "response": final_response,
                    "confidence": 0.95,  # High confidence due to thorough thinking
                    "source": "thinking_ai",
                    "thinking_process": reasoning_result,
                    "timestamp": datetime.now().isoformat()
                }
            else:
                # Fallback to simple response
                return self._generate_simple_fallback(original_query)
                
        except Exception as e:
            print(f"Error generating final response: {e}")
            return self._generate_simple_fallback(original_query)
    
    def _gather_knowledge_data(self, courses: List[str], track_context: str) -> Dict[str, Any]:
        """
        Gather relevant data from knowledge graph based on identified needs
        """
        
        conn = sqlite3.connect(self.kg.db_path)
        cursor = conn.cursor()
        
        knowledge_data = {
            "courses": {},
            "tracks": {},
            "prerequisites": {},
            "timing": {}
        }
        
        # Get course information
        for course in courses:
            cursor.execute('''
                SELECT code, title, credits, prerequisites, group_id, description
                FROM courses WHERE code = ? OR code LIKE ?
            ''', (course, f"%{course}%"))
            
            course_data = cursor.fetchone()
            if course_data:
                knowledge_data["courses"][course] = {
                    "code": course_data[0],
                    "title": course_data[1],
                    "credits": course_data[2],
                    "prerequisites": json.loads(course_data[3]) if course_data[3] else [],
                    "timing": course_data[4],
                    "description": course_data[5]
                }
        
        # Get track information if context provided
        if track_context:
            cursor.execute('SELECT * FROM tracks WHERE code = ?', (track_context,))
            track_data = cursor.fetchone()
            if track_data:
                knowledge_data["tracks"][track_context] = {
                    "name": track_data[1],
                    "required_courses": track_data[2],
                    "elective_courses": track_data[3],
                    "requirements": json.loads(track_data[5]) if track_data[5] else {}
                }
        
        conn.close()
        return knowledge_data
    
    def _fallback_analysis(self, query: str, track_context: str, error_info: str) -> Dict[str, Any]:
        """
        Simple fallback analysis when thinking process fails
        """
        return {
            "original_query": query,
            "track_context": track_context,
            "thinking_analysis": {
                "question_analysis": {
                    "primary_intent": "course_guidance",
                    "information_type": "timing_or_requirements",
                    "student_concerns": ["timing", "prerequisites"],
                    "detail_level": "basic"
                }
            },
            "fallback_reason": error_info,
            "timestamp": datetime.now().isoformat()
        }
    
    def _generate_simple_fallback(self, query: str) -> Dict[str, Any]:
        """
        Simple fallback response when thinking process fails
        """
        return {
            "query": query,
            "response": "I'd be happy to help you with that question! Let me look into the specific details and get back to you with accurate information about Purdue CS requirements.",
            "confidence": 0.5,
            "source": "fallback",
            "timestamp": datetime.now().isoformat()
        }

class ThinkingIntegration:
    """
    Integration class to add thinking capability to existing system
    """
    
    def __init__(self, existing_system, config):
        self.system = existing_system
        self.thinking_ai = ThinkingAIAdvisor(existing_system.kg, config)
        
    def enhanced_query_processing(self, query: str, track_context: str = None, use_thinking: bool = True) -> Dict[str, Any]:
        """
        Enhanced query processing with optional thinking layer
        """
        
        if use_thinking and self._should_use_thinking(query):
            print("ğŸ§  Using thinking layer for complex query...")
            return self.thinking_ai.process_query_with_thinking(query, track_context)
        else:
            print("âš¡ Using standard processing for simple query...")
            return self.system.generate_response(query, track_context)
    
    def _should_use_thinking(self, query: str) -> bool:
        """
        Determine if query is complex enough to warrant thinking process
        """
        
        complex_indicators = [
            "plan", "strategy", "timeline", "should i", "what if",
            "compare", "difference", "best approach", "recommend",
            "multiple", "both", "either", "complex", "confused"
        ]
        
        query_lower = query.lower()
        
        # Use thinking for complex queries
        if any(indicator in query_lower for indicator in complex_indicators):
            return True
        
        # Use thinking for multi-part questions
        if len(query.split('?')) > 2:
            return True
        
        # Use thinking for long queries (indicates complexity)
        if len(query.split()) > 15:
            return True
        
        return False

# Integration with existing system
def integrate_thinking_layer(existing_system, config):
    """
    Function to integrate thinking layer with existing Purdue CS AI system
    """
    
    print("ğŸ§  Integrating AI Thinking Layer...")
    
    # Create thinking integration
    thinking_integration = ThinkingIntegration(existing_system, config)
    
    # Replace the main query processing method
    original_method = existing_system.generate_response
    
    def enhanced_generate_response(query: str, track_context: str = None):
        return thinking_integration.enhanced_query_processing(query, track_context)
    
    existing_system.generate_response = enhanced_generate_response
    
    print("âœ… Thinking layer integrated successfully!")
    print("ğŸ¯ Complex queries will now use step-by-step reasoning")
    print("âš¡ Simple queries will use fast standard processing")
    
    return existing_system

# Example usage and testing
def test_thinking_system():
    """
    Test the thinking system with various query types
    """
    
    print("ğŸ§ª Testing AI Thinking System")
    print("=" * 50)
    
    # Mock config for testing
    config = {"anthropic_api_key": "your_api_key"}
    
    test_queries = [
        {
            "query": "When should I take CS 38100?",
            "expected_thinking": "Simple timing question - may not need thinking",
            "should_think": False
        },
        {
            "query": "I'm confused about planning my MI track. Should I take CS 37300 early or wait? What's the best strategy for balancing prerequisites with my timeline?",
            "expected_thinking": "Complex planning question - definitely needs thinking",
            "should_think": True
        },
        {
            "query": "What's the difference between MI and SE tracks and which would be better for someone interested in both AI and software development?",
            "expected_thinking": "Comparison and recommendation - needs thinking",
            "should_think": True
        }
    ]
    
    for i, test in enumerate(test_queries, 1):
        print(f"\nğŸ” Test {i}: {test['query'][:50]}...")
        
        # Test thinking decision
        integration = ThinkingIntegration(None, config)
        should_think = integration._should_use_thinking(test['query'])
        
        expected = test['should_think']
        result = "âœ… CORRECT" if should_think == expected else "âŒ INCORRECT"
        
        print(f"   Thinking needed: {should_think} (expected: {expected}) {result}")
        print(f"   Reason: {test['expected_thinking']}")
    
    print(f"\nğŸ¯ Thinking layer will provide more thoughtful, reasoned responses!")

if __name__ == "__main__":
    test_thinking_system()