class SETrackValidator:
    def __init__(self):
        # SE Track structure based on official website screenshots
        self.mandatory_courses = ["CS 30700", "CS 38100", "CS 40800", "CS 40700"]
        self.compilers_os_requirement = ["CS 35200", "CS 35400"]  # Choose 1
        
        self.elective_options = [
            "CS 31100", "CS 41100", "CS 34800", "CS 35100", "CS 35200",
            "CS 35300", "CS 35400", "CS 37300", "CS 42200", "CS 42600", 
            "CS 44800", "CS 45600", "CS 47100", "CS 47300", "CS 48900", 
            "CS 49000-DSO", "CS 49000-SWS", "CS 51000", "CS 59000-SRS"
        ]
    
    def validate_course_plan(self, selected_courses):
        """Validate if course selection meets SE track requirements"""
        errors = []
        warnings = []
        
        # Check mandatory courses
        for required in self.mandatory_courses:
            if required not in selected_courses:
                errors.append(f"Missing required course: {required}")
        
        # Check compilers/OS requirement (choose 1)
        compilers_os_selected = [c for c in selected_courses if c in self.compilers_os_requirement]
        if len(compilers_os_selected) == 0:
            errors.append(f"Must select 1 from Compilers/OS requirement: {self.compilers_os_requirement}")
        elif len(compilers_os_selected) > 1:
            warnings.append("Multiple Compilers/OS courses selected, only one needed for requirement")
            
        # Check electives
        selected_electives = [c for c in selected_courses if c in self.elective_options]
        
        # Remove courses already used for requirements to avoid double counting
        used_for_required = []
        used_for_required.extend([c for c in selected_courses if c in self.mandatory_courses])
        used_for_required.extend(compilers_os_selected)
        
        actual_electives = [c for c in selected_electives if c not in used_for_required]
        
        if len(actual_electives) < 1:
            errors.append(f"Must select 1 elective, currently have {len(actual_electives)}: {actual_electives}")
        elif len(actual_electives) > 1:
            warnings.append(f"More than 1 elective selected: {actual_electives}")
            
        # Check for double-counting
        double_counted = set(used_for_required) & set(actual_electives)
        if double_counted:
            errors.append(f"Courses cannot count for both required and elective: {list(double_counted)}")
            
        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "warnings": warnings,
            "summary": {
                "mandatory_completed": [c for c in self.mandatory_courses if c in selected_courses],
                "compilers_os_requirement": compilers_os_selected,
                "electives": actual_electives
            }
        }

# Testing and usage examples
def test_se_validator():
    """Test the SE track validator with various scenarios"""
    validator = SETrackValidator()
    
    print("üõ†Ô∏è Testing Software Engineering Track Validator")
    print("=" * 50)
    
    # Test 1: Valid complete plan
    print("\n1. Testing valid complete SE plan:")
    valid_plan = [
        "CS 30700",   # Mandatory: Software Engineering I
        "CS 35200",   # Choice: Compilers
        "CS 38100",   # Mandatory: Algorithms  
        "CS 40800",   # Mandatory: Software Testing
        "CS 40700",   # Mandatory: Senior Project
        "CS 42600"    # Elective: Computer Security
    ]
    
    result = validator.validate_course_plan(valid_plan)
    print(f"Plan: {valid_plan}")
    print(f"Valid: {result['valid']}")
    if result['errors']:
        print(f"Errors: {result['errors']}")
    print(f"Summary: {result['summary']}")
    
    # Test 2: Missing mandatory courses
    print("\n2. Testing plan missing mandatory courses:")
    incomplete_plan = ["CS 35200", "CS 37300"]
    
    result = validator.validate_course_plan(incomplete_plan)
    print(f"Plan: {incomplete_plan}")
    print(f"Valid: {result['valid']}")
    print(f"Errors: {result['errors']}")
    
    # Test 3: Missing compilers/OS requirement
    print("\n3. Testing plan missing compilers/OS choice:")
    no_compilers_os = ["CS 30700", "CS 38100", "CS 40800", "CS 40700", "CS 37300"]
    
    result = validator.validate_course_plan(no_compilers_os)
    print(f"Plan: {no_compilers_os}")
    print(f"Valid: {result['valid']}")
    print(f"Errors: {result['errors']}")
    
    # Test 4: Missing elective
    print("\n4. Testing plan missing elective:")
    no_elective = ["CS 30700", "CS 35200", "CS 38100", "CS 40800", "CS 40700"]
    
    result = validator.validate_course_plan(no_elective)
    print(f"Plan: {no_elective}")
    print(f"Valid: {result['valid']}")
    print(f"Errors: {result['errors']}")
    
    # Test 5: Double counting
    print("\n5. Testing double counting (CS 35200 for both required and elective):")
    double_count = ["CS 30700", "CS 35200", "CS 38100", "CS 40800", "CS 40700", "CS 35200"]
    
    result = validator.validate_course_plan(double_count)
    print(f"Plan: {double_count}")
    print(f"Valid: {result['valid']}")
    print(f"Errors: {result['errors']}")
    
    # Test 6: Alternative valid plan with Operating Systems
    print("\n6. Testing alternative valid plan with Operating Systems:")
    os_plan = [
        "CS 30700",   # Mandatory: Software Engineering I
        "CS 35400",   # Choice: Operating Systems
        "CS 38100",   # Mandatory: Algorithms  
        "CS 40800",   # Mandatory: Software Testing
        "CS 40700",   # Mandatory: Senior Project
        "CS 47100"    # Elective: AI
    ]
    
    result = validator.validate_course_plan(os_plan)
    print(f"Plan: {os_plan}")
    print(f"Valid: {result['valid']}")
    if result['errors']:
        print(f"Errors: {result['errors']}")
    print(f"Summary: {result['summary']}")

if __name__ == "__main__":
    test_se_validator()

# Additional utility functions for SE track

def get_se_requirements_summary():
    """Get a summary of SE track requirements"""
    return {
        "track_name": "Software Engineering Track",
        "total_courses": 6,
        "structure": {
            "required_courses": 5,
            "mandatory": ["CS 30700", "CS 38100", "CS 40800", "CS 40700"],
            "choice_requirements": {
                "compilers_os": {
                    "description": "Choose 1 from Compilers or Operating Systems",
                    "options": ["CS 35200", "CS 35400"],
                    "choose": 1
                }
            },
            "electives": {
                "count": 1,
                "description": "Choose 1 from approved elective list"
            }
        },
        "special_notes": [
            "EPICS can replace CS 40700 with track chair approval",
            "CS 31100 + CS 41100 combination counts as one elective",
            "No double counting between required and elective"
        ]
    }

def validate_se_course_substitutions(plan, substitutions):
    """
    Validate SE course plan with possible substitutions
    
    Args:
        plan: List of selected courses
        substitutions: Dict of substitutions like {"CS 40700": "EPICS"}
    """
    validator = SETrackValidator()
    
    # Apply substitutions
    modified_plan = plan.copy()
    for original, substitute in substitutions.items():
        if substitute in ["EPICS", "VIP"] and original == "CS 40700":
            # Special handling for senior project substitutions
            if original in modified_plan:
                modified_plan.remove(original)
            print(f"‚ÑπÔ∏è Substituting {original} with {substitute} (requires track chair approval)")
    
    return validator.validate_course_plan(modified_plan)

def get_se_elective_recommendations(interests):
    """
    Recommend SE electives based on student interests
    
    Args:
        interests: List of interest areas like ["security", "ai", "databases"]
    """
    recommendations = {
        "security": ["CS 42600", "CS 49000-SWS", "CS 59000-SRS"],
        "ai": ["CS 47100", "CS 37300", "CS 47300"],
        "systems": ["CS 35400", "CS 48900", "CS 49000-DSO"],
        "databases": ["CS 44800"],
        "networking": ["CS 42200"],
        "cloud": ["CS 35100"],
        "languages": ["CS 45600", "CS 35200"],
        "advanced_se": ["CS 51000"],
        "parallel": ["CS 35300"]
    }
    
    suggested = []
    for interest in interests:
        if interest.lower() in recommendations:
            suggested.extend(recommendations[interest.lower()])
    
    # Remove duplicates and return
    return list(set(suggested))