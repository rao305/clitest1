#### **4. N8N Workflow with Prerequisite Intelligence**

```javascript
// n8n-prerequisite-workflow.json
{
  "name": "Purdue CS Curriculum with Prerequisite Intelligence",
  "nodes": [
    {
      "name": "Prerequisite Validator",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
          // Validate prerequisite chains and detect issues
          const courses = items[0].json.courses;
          const prerequisiteMap = items[0].json.prerequisiteMap;
          
          const issues = [];
          const validatedCourses = [];
          
          courses.forEach(course => {
            const courseKey = course.code.replace(/\\s/g, '');
            const knownPrereqs = prerequisiteMap[courseKey];
            
            // Check for discrepancies
            if (knownPrereqs && course.scrapedPrerequisites) {
              const knownSet = new Set(knownPrereqs.prerequisites);
              const scrapedSet = new Set(course.scrapedPrerequisites);
              
              // Find missing prerequisites
              const missing = [...knownSet].filter(p => !scrapedSet.has(p));
              const extra = [...scrapedSet].filter(p => !knownSet.has(p));
              
              if (missing.length > 0 || extra.length > 0) {
                issues.push({
                  course: course.code,
                  missing,
                  extra,
                  severity: 'warning'
                });
              }
            }
            
            // Add validated prerequisite data
            validatedCourses.push({
              ...course,
              prerequisites: knownPrereqs ? knownPrereqs.prerequisites : course.scrapedPrerequisites,
              validatedAt: new Date().toISOString()
            });
          });
          
          return {
            validatedCourses,
            issues,
            totalCourses: courses.length,
            issueCount: issues.length
          };
        `
      }
    },
    {
      "name": "Generate Prerequisite Graph",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
          // Generate visual prerequisite graph data
          const courses = items[0].json.validatedCourses;
          
          const nodes = [];
          const edges = [];
          const levels = new Map();
          
          // Categorize courses by level
          courses.forEach(course => {
            const level = Math.floor(parseInt(course.code.match(/\\d+/)[0]) / 100);
            
            nodes.push({
              id: course.code.replace(/\\s/g, ''),
              label: course.code,
              title: course.title,
              level: level,
              type: course.isCore ? 'core' : 'elective',
              track: course.trackRequired || []
            });
            
            // Create edges for prerequisites
            if (course.prerequisites) {
              course.prerequisites.forEach(prereq => {
                edges.push({
                  from: prereq,
                  to: course.code.replace(/\\s/g, ''),
                  type: 'prerequisite',
                  style: 'solid'
                });
              });
            }
            
            // Create edges for corequisites
            if (course.corequisites) {
              course.corequisites.forEach(coreq => {
                edges.push({
                  from: coreq,
                  to: course.code.replace(/\\s/g, ''),
                  type: 'corequisite',
                  style: 'dashed'
                });
              });
            }
          });
          
          return {
            graph: {
              nodes,
              edges,
              metadata: {
                totalNodes: nodes.length,
                totalEdges: edges.length,
                generatedAt: new Date().toISOString()
              }
            }
          };
        `
      }
    },
    {
      "name": "Track Analyzer",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
          // Analyze track requirements and generate recommendations
          const courses = items[0].json.validatedCourses;
          const tracks = ['machine_intelligence', 'software_engineering'];
          
          const trackAnalysis = {};
          
          tracks.forEach(track => {
            const trackCourses = courses.filter(c => 
              c.trackRequired && c.trackRequired.includes(track)
            );
            
            // Calculate optimal course sequence
            const sequence = [];
            const completed = new Set();
            
            // Start with courses that have no prerequisites
            let remaining = [...trackCourses];
            
            while (remaining.length > 0) {
              const available = remaining.filter(course => {
                if (!course.prerequisites || course.prerequisites.length === 0) {
                  return true;
                }
                return course.prerequisites.every(p => completed.has(p));
              });
              
              if (available.length === 0) {
                // Circular dependency or missing prerequisite
                break;
              }
              
              // Add available courses to sequence
              available.forEach(course => {
                sequence.push(course.code);
                completed.add(course.code.replace(/\\s/g, ''));
                remaining = remaining.filter(c => c.code !== course.code);
              });
            }
            
            trackAnalysis[track] = {
              requiredCourses: trackCourses.map(c => c.code),
              recommendedSequence: sequence,
              totalCredits: trackCourses.reduce((sum, c) => sum + (c.credits || 3), 0),
              estimatedSemesters: Math.ceil(sequence.length / 2)
            };
          });
          
          return trackAnalysis;
        `
      }
    }
  ]
}
```

#### **5. API Endpoints with Prerequisite Intelligence**

```javascript
// api/routes/prerequisites.js
const express = require('express');
const router = express.Router();

// GET /api/curriculum/prerequisites/:courseCode
router.get('/prerequisites/:courseCode', async (req, res) => {
  const { courseCode } = req.params;
  const { detailed } = req.query;
  
  try {
    const builder = new PrerequisiteChainBuilder(prerequisiteMap);
    const chainData = builder.getCompletePrerequisiteChain(courseCode);
    const longestPath = builder.getLongestPath(courseCode);
    
    if (detailed === 'true') {
      // Return detailed prerequisite analysis
      res.json({
        course: courseCode,
        direct: chainData.direct,
        all: chainData.all,
        chains: chainData.chain,
        longestPath,
        depth: longestPath.length - 1,
        canTakeAfter: chainData.all // All prerequisites that must be completed
      });
    } else {
      // Return simple prerequisite list
      res.json({
        course: courseCode,
        prerequisites: chainData.direct,
        allPrerequisites: chainData.all
      });
    }
  } catch (error) {
    res.status(404).json({ error: 'Course not found' });
  }
});

// POST /api/curriculum/validate-schedule
router.post('/validate-schedule', async (req, res) => {
  const { completedCourses, plannedCourses } = req.body;
  const builder = new PrerequisiteChainBuilder(prerequisiteMap);
  
  const validation = {
    valid: true,
    issues: [],
    recommendations: []
  };
  
  plannedCourses.forEach(courseCode => {
    if (!builder.canTakeCourse(courseCode, completedCourses)) {
      validation.valid = false;
      const course = prerequisiteMap[courseCode];
      const missing = course.prerequisites.filter(p => !completedCourses.includes(p));
      
      validation.issues.push({
        course: courseCode,
        missingPrerequisites: missing,
        message: `Cannot take ${courseCode} without completing: ${missing.join(', ')}`
      });
    }
  });
  
  // Generate recommendations
  const allCourses = Object.keys(prerequisiteMap);
  const available = allCourses.filter(courseCode => 
    builder.canTakeCourse(courseCode, completedCourses) &&
    !completedCourses.includes(courseCode) &&
    !plannedCourses.includes(courseCode)
  );
  
  validation.recommendations = available.slice(0, 5);
  
  res.json(validation);
});

// GET /api/curriculum/roadmap/:track
router.get('/roadmap/:track', async (req, res) => {
  const { track } = req.params;
  const builder = new PrerequisiteChainBuilder(prerequisiteMap);
  
  const sequence = builder.generateTrackSequence(track);
  if (!sequence) {
    return res.status(404).json({ error: 'Track not found' });
  }
  
  // Generate semester-by-semester plan
  const roadmap = {
    track,
    semesters: []
  };
  
  const allCourses = [...sequence.math, ...sequence.core, ...sequence.required];
  const completed = new Set();
  
  // Simulate 8 semesters
  for (let sem = 1; sem <= 8; sem++) {
    const semesterCourses = [];
    const available = allCourses.filter(courseCode => 
      !completed.has(courseCode) &&
      builder.canTakeCourse(courseCode, [...completed])
    );
    
    // Take up to 4 courses per semester
    available.slice(0, 4).forEach(courseCode => {
      semesterCourses.push({
        code: courseCode,
        title: prerequisiteMap[courseCode]?.title || courseCode,
        credits: 3
      });
      completed.add(courseCode);
    });
    
    if (semesterCourses.length > 0) {
      roadmap.semesters.push({
        number: sem,
        courses: semesterCourses,
        totalCredits: semesterCourses.length * 3
      });
    }
  }
  
  res.json(roadmap);
});

module.exports = router;
```

#### **6. Testing Suite for Prerequisites**

```javascript
// test-prerequisites-accuracy.js
const assert = require('assert');

function testPrerequisiteChains() {
  console.log('ðŸ§ª Testing Prerequisite Chain Accuracy...\n');
  
  const builder = new PrerequisiteChainBuilder(prerequisiteMap);
  
  // Test cases based on the flowchart
  const testCases = [
    {
      course: 'CS373',
      expectedDirect: ['CS252', 'STAT350'],
      expectedAll: ['CS252', 'STAT350', 'CS250', 'CS251', 'CS182', 'CS240', 'CS180', 'MA162', 'MA161']
    },
    {
      course: 'CS381',
      expectedDirect: ['CS252', 'MA261'],
      expectedAll: ['CS252', 'MA261', 'CS250', 'CS251', 'CS182', 'CS240', 'CS180', 'MA162', 'MA161']
    },
    {
      course: 'CS408',
      expectedDirect: ['CS251'],
      expectedAll: ['CS251', 'CS182', 'CS240', 'CS180']
    },
    {
      course: 'CS483',
      expectedDirect: ['CS381'],
      expectedAll: ['CS381', 'CS252', 'MA261', 'CS250', 'CS251', 'CS182', 'CS240', 'CS180', 'MA162', 'MA161']
    }
  ];
  
  let passed = 0;
  let failed = 0;
  
  testCases.forEach(test => {
    const result = builder.getCompletePrerequisiteChain(test.course);
    
    try {
      assert.deepEqual(new Set(result.direct), new Set(test.expectedDirect));
      assert.deepEqual(new Set(result.all), new Set(test.expectedAll));
      console.log(`âœ… ${test.course}: Prerequisites correct`);
      passed++;
    } catch (error) {
      console.log(`âŒ ${test.course}: Prerequisites mismatch`);
      console.log(`   Expected direct: ${test.expectedDirect.join(', ')}`);
      console.log(`   Got direct: ${result.direct.join(', ')}`);
      failed++;
    }
  });
  
  console.log(`\nðŸ“Š Results: ${passed} passed, ${failed} failed`);
  
  // Test longest path
  console.log('\nðŸ” Testing Longest Prerequisite Paths:');
  ['CS373', 'CS381', 'CS483', 'CS408'].forEach(course => {
    const path = builder.getLongestPath(course);
    console.log(`${course}: ${path.join(' â†’ ')}`);
  });
}

// Run the test
testPrerequisiteChains();
```

### **Key Improvements Made:**

1. **Accurate Prerequisite Mapping**: Based on the official flowchart, all prerequisite relationships are now correct
2. **Corequisite Support**: Handles courses that can be taken concurrently (dashed lines)
3. **Either/Or Prerequisites**: Handles dotted line relationships where either prerequisite works
4. **External Prerequisites**: Properly tracks MA/STAT requirements
5. **Prerequisite Chain Builder**: Intelligent system to find all prerequisites recursively
6. **Validation System**: Checks scraped data against known prerequisites
7. **Track Sequence Generator**: Creates valid course sequences respecting prerequisites
8. **Schedule Validator**: Ensures students can actually take planned courses

### **Critical Notes for Implementation:**

- **Grade Requirements**: All CS prerequisites require C or better
- **Core Sequence**: CS 180 â†’ CS 182/240 â†’ CS 250/251 â†’ CS 252
- **Math Sequence**: MA 161 â†’ MA 162 â†’ MA 261 â†’ MA 265
- **Stats Path**: MA 162 â†’ STAT 350
- **Track-Specific**: Each track has specific required courses with strict prerequisites

This system will ensure your scraper maintains accurate prerequisite information and can provide intelligent course planning assistance.