#!/usr/bin/env python3
"""
CORRECTED Test script to verify the Machine Intelligence track scraper matches official website
Based on actual screenshots from https://www.cs.purdue.edu/undergraduate/curriculum/track-mI-fall2023.html
"""

import json
from mi_track_scraper import PurdueMITrackScraper
from course_validator import MITrackValidator

def test_scraper_accuracy():
    """Test that scraper matches the exact website structure from screenshots"""
    print("üîç Testing Scraper Accuracy Against Official Website...")
    
    scraper = PurdueMITrackScraper()
    data = scraper.scrape_courses()
    
    if not data:
        print("‚ùå Scraper failed to retrieve data")
        return False
    
    # Verify required courses structure matches screenshots
    required = data.get('required_courses', [])
    if len(required) != 4:
        print(f"‚ùå Expected 4 required course items, got {len(required)}")
        return False
    
    # Check for CS 37300 (Data Mining and Machine Learning)
    cs37300_found = False
    for req in required:
        if any(course['course_code'] == 'CS 37300' for course in req['courses']):
            cs37300_found = True
            break
    
    if not cs37300_found:
        print("‚ùå CS 37300 (Data Mining and Machine Learning) not found in required courses")
        return False
    
    # Check for CS 38100 (Introduction to the Analysis of Algorithms)  
    cs38100_found = False
    for req in required:
        if any(course['course_code'] == 'CS 38100' for course in req['courses']):
            cs38100_found = True
            break
    
    if not cs38100_found:
        print("‚ùå CS 38100 (Introduction to the Analysis of Algorithms) not found in required courses")
        return False
    
    # Verify electives structure
    electives = data.get('elective_courses', {})
    if electives.get('choose') != 2:
        print(f"‚ùå Expected 2 electives required, got {electives.get('choose')}")
        return False
    
    # Check for key elective courses from screenshots
    elective_codes = [opt['course_code'] for opt in electives.get('options', [])]
    
    required_electives = ['CS 31100', 'CS 34800', 'CS 47100', 'CS 57700', 'CS 57800']
    for req_elective in required_electives:
        if req_elective not in elective_codes:
            print(f"‚ùå Missing expected elective: {req_elective}")
            return False
    
    print("‚úÖ Scraper accurately matches website structure")
    return True

def test_mandatory_courses():
    """Test that mandatory courses are correctly identified"""
    print("\nüéØ Testing Mandatory Course Identification...")
    
    validator = MITrackValidator()
    
    # CS 37300 and CS 38100 should be mandatory
    expected_mandatory = ['CS 37300', 'CS 38100']
    
    if set(validator.mandatory_courses) != set(expected_mandatory):
        print(f"‚ùå Wrong mandatory courses. Expected: {expected_mandatory}, Got: {validator.mandatory_courses}")
        return False
    
    # Test validation with missing mandatory courses
    incomplete_selection = ["CS 47100", "STAT 41600", "CS 34800", "CS 45600"]  # Missing both mandatory
    result = validator.validate_course_plan(incomplete_selection)
    
    if result['valid']:
        print("‚ùå Missing mandatory courses not detected")
        return False
    
    # Should have 2 errors for missing CS 37300 and CS 38100
    mandatory_errors = [err for err in result['errors'] if 'CS 37300' in err or 'CS 38100' in err]
    if len(mandatory_errors) != 2:
        print(f"‚ùå Expected 2 mandatory course errors, got {len(mandatory_errors)}")
        return False
    
    print("‚úÖ Mandatory course validation working correctly")
    return True

def test_choice_requirements():
    """Test the choice requirements (AI and Statistics)"""
    print("\n‚ö° Testing Choice Requirements...")
    
    validator = MITrackValidator()
    
    # Test AI requirement
    ai_options = validator.ai_requirement
    if 'CS 47100' not in ai_options or 'CS 47300' not in ai_options:
        print(f"‚ùå AI requirement options wrong: {ai_options}")
        return False
    
    # Test stats requirement  
    stats_options = validator.stats_requirement
    expected_stats = ['STAT 41600', 'MA 41600', 'STAT 51200']
    if set(stats_options) != set(expected_stats):
        print(f"‚ùå Statistics requirement options wrong. Expected: {expected_stats}, Got: {stats_options}")
        return False
    
    # Test missing choice requirements
    incomplete = ["CS 37300", "CS 38100", "CS 34800", "CS 45600"]  # Missing AI and stats choices
    result = validator.validate_course_plan(incomplete)
    
    if result['valid']:
        print("‚ùå Missing choice requirements not detected")
        return False
    
    print("‚úÖ Choice requirements validation working correctly")
    return True

def test_elective_constraints():
    """Test elective-specific constraints"""
    print("\nüé® Testing Elective Constraints...")
    
    validator = MITrackValidator()
    
    # Test data visualization group constraint (can only choose 1 from CS 43900/CS 44000/CS 47500)
    complete_required = ["CS 37300", "CS 38100", "CS 47100", "STAT 41600"]
    
    # Try to select multiple from data viz group
    invalid_electives = complete_required + ["CS 43900", "CS 44000"]  # Both from data viz group
    result = validator.validate_course_plan(invalid_electives)
    
    if result['valid']:
        print("‚ùå Data visualization group constraint not enforced")
        return False
    
    # Valid elective selection
    valid_electives = complete_required + ["CS 43900", "CS 34800"]  # One from data viz group + regular
    result = validator.validate_course_plan(valid_electives)
    
    if not result['valid']:
        print(f"‚ùå Valid elective selection marked invalid: {result['errors']}")
        return False
    
    print("‚úÖ Elective constraints working correctly")
    return True

def test_double_counting_prevention():
    """Test that double counting is prevented"""
    print("\nüö´ Testing Double Counting Prevention...")
    
    validator = MITrackValidator()
    
    # Try to use CS 47300 for both required and elective
    double_count = ["CS 37300", "CS 38100", "CS 47300", "STAT 41600", "CS 47300", "CS 34800"]
    result = validator.validate_course_plan(double_count)
    
    if result['valid']:
        print("‚ùå Double counting not detected")
        return False
    
    # Verify error message mentions double counting
    double_count_error = any('both required and elective' in err.lower() for err in result['errors'])
    if not double_count_error:
        print("‚ùå Double counting error not properly reported")
        return False
    
    print("‚úÖ Double counting prevention working correctly")
    return True

def test_complete_valid_plan():
    """Test a completely valid course plan"""
    print("\n‚úÖ Testing Complete Valid Plan...")
    
    validator = MITrackValidator()
    
    # A valid complete plan
    valid_plan = [
        "CS 37300",   # Mandatory 1
        "CS 38100",   # Mandatory 2  
        "CS 47100",   # AI choice
        "STAT 41600", # Stats choice
        "CS 34800",   # Elective 1
        "CS 57700"    # Elective 2
    ]
    
    result = validator.validate_course_plan(valid_plan)
    
    if not result['valid']:
        print(f"‚ùå Valid plan marked as invalid: {result['errors']}")
        return False
    
    # Check summary
    summary = result['summary']
    if len(summary['mandatory_completed']) != 2:
        print(f"‚ùå Wrong mandatory count in summary: {summary['mandatory_completed']}")
        return False
    
    if len(summary['electives']) != 2:
        print(f"‚ùå Wrong elective count in summary: {summary['electives']}")
        return False
    
    print("‚úÖ Complete valid plan verification working correctly")
    return True

def test_ai_responses():
    """Test that AI guidance matches website structure"""
    print("\nü§ñ Testing AI Response Accuracy...")
    
    scraper = PurdueMITrackScraper()
    
    # Test required courses response
    response = scraper.get_course_guidance("What are the required courses?")
    
    # Should mention CS 37300 and CS 38100 specifically
    if 'CS 37300' not in response or 'CS 38100' not in response:
        print("‚ùå Required courses response missing CS 37300 or CS 38100")
        return False
    
    # Should mention Data Mining and Machine Learning
    if 'Data Mining' not in response:
        print("‚ùå Required courses response missing 'Data Mining'")
        return False
    
    # Test electives response
    elective_response = scraper.get_course_guidance("Tell me about electives")
    
    # Should mention choosing 2
    if '2' not in elective_response:
        print("‚ùå Elective response doesn't mention choosing 2")
        return False
    
    print("‚úÖ AI response accuracy verified")
    return True

def generate_comprehensive_test_report():
    """Generate comprehensive test report matching official website"""
    print("=" * 70)
    print("üéØ MACHINE INTELLIGENCE TRACK VERIFICATION REPORT")
    print("üìã Based on Official Website Screenshots")
    print("=" * 70)
    
    tests = [
        ("Website Structure Match", test_scraper_accuracy),
        ("Mandatory Courses (CS 37300, CS 38100)", test_mandatory_courses),
        ("Choice Requirements (AI + Stats)", test_choice_requirements), 
        ("Elective Constraints", test_elective_constraints),
        ("Double Counting Prevention", test_double_counting_prevention),
        ("Complete Valid Plan", test_complete_valid_plan),
        ("AI Response Accuracy", test_ai_responses)
    ]
    
    results = {}
    all_passed = True
    
    for test_name, test_func in tests:
        try:
            results[test_name] = test_func()
            all_passed = all_passed and results[test_name]
        except Exception as e:
            print(f"‚ùå {test_name} failed with error: {e}")
            results[test_name] = False
            all_passed = False
    
    print("\n" + "=" * 70)
    print("üìã DETAILED TEST SUMMARY")
    print("=" * 70)
    
    for test_name, passed in results.items():
        status = "‚úÖ PASS" if passed else "‚ùå FAIL"
        print(f"{test_name:35} {status}")
    
    print("\n" + "=" * 70)
    print("üîç VERIFICATION CHECKLIST")
    print("=" * 70)
    print("‚úì CS 37300 (Data Mining and Machine Learning) - Required")
    print("‚úì CS 38100 (Introduction to Analysis of Algorithms) - Required") 
    print("‚úì CS 47100 OR CS 47300 - Choose 1")
    print("‚úì STAT 41600 OR MA 41600 OR STAT 51200 - Choose 1")
    print("‚úì 2 Electives from approved list")
    print("‚úì Data visualization group constraint (CS 43900/44000/47500)")
    print("‚úì No double counting enforcement")
    
    print("\n" + "=" * 70)
    if all_passed:
        print("üéâ ALL TESTS PASSED!")
        print("‚úÖ Implementation matches official Purdue website exactly")
        print("‚úÖ AI now has 100% accurate Machine Intelligence track information")
        print("‚úÖ Ready for production use")
    else:
        print("‚ö†Ô∏è  SOME TESTS FAILED")
        print("üìã Review failed tests and fix implementation")
        print("üîß Ensure all components match the website screenshots")
    
    print("=" * 70)
    
    return all_passed

def debug_website_comparison():
    """Show exact comparison with website screenshots"""
    print("\nüîç DEBUGGING: Exact Website Comparison")
    print("-" * 60)
    
    print("WEBSITE SCREENSHOT - Required Courses (4):")
    print("1. CS 37300 - Data Mining and Machine Learning")
    print("2. CS 38100 - Introduction to the Analysis of Algorithms")  
    print("3. CS 47100 - Artificial Intelligence")
    print("   OR CS 47300 - Web Information Search & Management")
    print("4. STAT 41600 - Probability")
    print("   OR MA 41600 - Probability") 
    print("   OR STAT 51200 - Applied Regression Analysis")
    
    print("\nWEBSITE SCREENSHOT - Electives (2):")
    print("Choose 2 from:")
    print("- CS 31100 (+ CS 41100) - Competitive Programming")
    print("- CS 31400 - Numerical Methods")
    print("- CS 34800 - Information Systems")
    print("- CS 35200 - Compilers: Principles And Practice")
    print("- CS 44800 - Introduction To Relational Database Systems")
    print("- CS 45600 - Programming Languages") 
    print("- CS 45800 - Introduction to Robotics")
    print("- CS 47100 - Introduction to Artificial Intelligence")
    print("- CS 47300 - Web Information Search & Management")
    print("- CS 48300 - Introduction To The Theory Of Computation")
    print("- CS 43900 - Introduction to Data Visualization")
    print("  OR CS 44000 - Large-Scale Data Analytics")
    print("  OR CS 47500 - Human-Computer Interactions")
    print("- CS 57700 - Natural Language Processing")
    print("- CS 57800 - Statistical Machine Learning")
    
    print("\nImplementation should match this EXACTLY!")

if __name__ == "__main__":
    generate_comprehensive_test_report()
    debug_website_comparison()

# Additional verification utilities

def verify_against_screenshots():
    """Manual verification checklist against screenshots"""
    print("\nüì∏ SCREENSHOT VERIFICATION CHECKLIST")
    print("-" * 50)
    print("‚ñ° Required Courses table shows exactly 4 courses")
    print("‚ñ° CS 37300 'Data Mining and Machine Learning' is listed first")
    print("‚ñ° CS 38100 'Introduction to the Analysis of Algorithms' is listed second")
    print("‚ñ° CS 47100 OR CS 47300 choice is shown")
    print("‚ñ° STAT 41600 OR MA 41600 OR STAT 51200 choice is shown")
    print("‚ñ° Electives table shows 'Electives (2)'")
    print("‚ñ° Data visualization group shows CS 43900 OR CS 44000 OR CS 47500")
    print("‚ñ° Competitive programming note about CS 31100 + CS 41100")
    print("‚ñ° All course titles match screenshots exactly")
    print("\nManually verify each item above against the website screenshots!")

def export_training_data():
    """Export the correct training data for AI"""
    scraper = PurdueMITrackScraper()
    data = scraper.scrape_courses()
    
    training_export = {
        "verified_against": "Official website screenshots 2025-07-17",
        "track_data": data,
        "training_instructions": "Use this exact structure for AI training. Clear any previous incorrect data first."
    }
    
    with open('mi_track_training_data.json', 'w') as f:
        json.dump(training_export, f, indent=2)
    
    print("üìÅ Training data exported to 'mi_track_training_data.json'")
    print("üìã Use this file to train your AI with 100% accurate information")